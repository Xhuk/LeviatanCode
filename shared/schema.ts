import { sql } from "drizzle-orm";
import { pgTable, text, varchar, jsonb, timestamp, boolean, integer } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  passwordHash: text("password_hash").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

export const projects = pgTable("projects", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  description: text("description"),
  userId: varchar("user_id").notNull(),
  files: jsonb("files").notNull().default({}),
  config: jsonb("config").notNull().default({}),
  documentation: jsonb("documentation").$type<ProjectDocumentation>(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const projectExecutions = pgTable("project_executions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  projectId: varchar("project_id").notNull(),
  name: text("name").notNull(),
  command: text("command").notNull(), // e.g., "npm run dev", "python main.py"
  workingDirectory: text("working_directory"),
  status: text("status").notNull().default("pending"), // 'pending', 'running', 'completed', 'failed'
  output: text("output"),
  error: text("error"),
  exitCode: integer("exit_code"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  completedAt: timestamp("completed_at"),
});

export const aiChats = pgTable("ai_chats", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  projectId: varchar("project_id").notNull(),
  title: text("title").notNull().default("New Chat"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const messages = pgTable("messages", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  chatId: varchar("chat_id").notNull(),
  role: text("role").notNull(), // 'user' or 'assistant'
  content: text("content").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

export const documentation = pgTable("documentation", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  projectId: varchar("project_id").notNull(),
  fileName: text("file_name").notNull(),
  content: text("content").notNull(),
  autoGenerated: boolean("auto_generated").notNull().default(true),
  lastUpdated: timestamp("last_updated").notNull().defaultNow(),
});

export const promptTemplates = pgTable("prompt_templates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  projectId: varchar("project_id").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  category: text("category").notNull(), // 'code_analysis', 'documentation', 'data_analysis', 'general', 'custom'
  promptText: text("prompt_text").notNull(),
  variables: jsonb("variables").notNull().default([]), // Array of variable names like ['fileName', 'codeContent']
  isActive: boolean("is_active").notNull().default(true),
  isDefault: boolean("is_default").notNull().default(false),
  usageCount: integer("usage_count").notNull().default(0),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const vaultSecrets = pgTable("vault_secrets", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  workspace: text("workspace").notNull(), // workspace/project name
  name: text("name").notNull(),
  encryptedValue: text("encrypted_value").notNull(), // encrypted secret value
  description: text("description"),
  category: text("category").default("general"), // 'git', 'database', 'api', 'general'
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

// Project Documentation Interface
export interface ProjectDocumentation {
  overview: string;
  techStack: string[];
  architecture: string;
  dependencies: string[];
  setupInstructions: string;
  deploymentInfo: string;
  apis: string[];
  databases: string[];
  keyFiles: Record<string, string>; // filepath -> description
  features: string[];
  notes: string;
}

// Insert schemas
export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  passwordHash: true,
});

export const insertProjectSchema = createInsertSchema(projects).pick({
  name: true,
  description: true,
  userId: true,
  files: true,
  config: true,
  documentation: true,
});

export const insertProjectExecutionSchema = createInsertSchema(projectExecutions).pick({
  projectId: true,
  name: true,
  command: true,
  workingDirectory: true,
});

export const insertAiChatSchema = createInsertSchema(aiChats).pick({
  projectId: true,
  title: true,
});

export const insertDocumentationSchema = createInsertSchema(documentation).pick({
  projectId: true,
  fileName: true,
  content: true,
  autoGenerated: true,
});

export const insertPromptTemplateSchema = createInsertSchema(promptTemplates).pick({
  projectId: true,
  name: true,
  description: true,
  category: true,
  promptText: true,
  variables: true,
  isActive: true,
  isDefault: true,
});

export const insertVaultSecretSchema = createInsertSchema(vaultSecrets).pick({
  workspace: true,
  name: true,
  encryptedValue: true,
  description: true,
  category: true,
});

// Types
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

export type InsertProject = z.infer<typeof insertProjectSchema>;
export type Project = typeof projects.$inferSelect;

export type InsertProjectExecution = z.infer<typeof insertProjectExecutionSchema>;
export type ProjectExecution = typeof projectExecutions.$inferSelect;

export type InsertAiChat = z.infer<typeof insertAiChatSchema>;
export type AiChat = typeof aiChats.$inferSelect;

export type InsertDocumentation = z.infer<typeof insertDocumentationSchema>;
export type Documentation = typeof documentation.$inferSelect;

export type InsertPromptTemplate = z.infer<typeof insertPromptTemplateSchema>;
export type PromptTemplate = typeof promptTemplates.$inferSelect;

export type InsertVaultSecret = z.infer<typeof insertVaultSecretSchema>;
export type VaultSecret = typeof vaultSecrets.$inferSelect;

// Message types for AI chat
export interface ChatMessage {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: Date;
  model?: string;
}

export interface FileSystemItem {
  name: string;
  type: "file" | "folder";
  path: string;
  children?: FileSystemItem[];
  language?: string;
  size?: number;
  lastModified?: Date;
}

export interface ScrapingConfig {
  selector?: string;
  headers?: Record<string, string>;
  rateLimit?: number;
  maxPages?: number;
  followLinks?: boolean;
  dataPoints: string[];
}

export interface AnalysisResult {
  insights: string[];
  metrics: Record<string, number>;
  recommendations: string[];
  visualizations?: any[];
}

// insightsproject.ia file structure for persistent AI context
export interface ProjectInsightsFile {
  version: string;
  projectId: string;
  projectName: string;
  projectPath: string;
  createdAt: string;
  lastAnalyzed: string;
  lastModified: string;
  
  // Core project metadata
  projectType: string;
  primaryLanguages: string[];
  frameworks: string[];
  dependencies: Record<string, string>;
  
  // File structure and content analysis
  totalFiles: number;
  totalLinesOfCode: number;
  fileTypes: Record<string, number>;
  
  // AI analysis results
  aiSummary: string;
  technologies: string[];
  insights: string[];
  recommendations: string[];
  setupInstructions: string[];
  runCommands: string[];
  
  // Context for AI conversations
  projectContext: string;
  previousAnalyses: {
    timestamp: string;
    summary: string;
    changes: string[];
  }[];
  
  // Development environment
  workingDirectory: string;
  mainEntryPoints: string[];
  configFiles: string[];
  
  // User preferences and notes
  userNotes: string;
  customSettings: Record<string, any>;
}
